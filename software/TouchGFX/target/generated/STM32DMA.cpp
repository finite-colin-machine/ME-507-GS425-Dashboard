/**
  ******************************************************************************
  * File Name          : STM32DMA.cpp
  ******************************************************************************
  * This file is generated by TouchGFX Generator 4.25.0. Please, do not edit!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#include "stm32f7xx_hal.h"
#include "stm32f7xx_hal_dma2d.h"
#include <STM32DMA.hpp>
#include <cassert>
#include <touchgfx/hal/HAL.hpp>
#include <touchgfx/hal/Paint.hpp>

/* Makes touchgfx specific types and variables visible to this file */
using namespace touchgfx;

typedef struct
{
    const uint16_t format;
    const uint16_t size;
    const uint32_t* const data;
} clutData_t;

extern "C" DMA2D_HandleTypeDef hdma2d;

extern "C" {
    static void DMA2D_XferCpltCallback(DMA2D_HandleTypeDef* handle)
    {
        (void)handle; // Unused argument
        HAL::getInstance()->signalDMAInterrupt();
    }

    static void DMA2D_XferErrorCallback(DMA2D_HandleTypeDef* handle)
    {
        (void)handle; // Unused argument
        while (1)
        {

        }
    }
}

STM32DMA::STM32DMA()
    : DMA_Interface(dma_queue), dma_queue(queue_storage, sizeof(queue_storage) / sizeof(queue_storage[0]))
{
}

STM32DMA::~STM32DMA()
{
    /* Disable DMA2D global Interrupt */
    NVIC_DisableIRQ(DMA2D_IRQn);
}

void STM32DMA::initialize()
{
    /* Ensure DMA2D Clock is enabled */
    __HAL_RCC_DMA2D_CLK_ENABLE();
    __HAL_RCC_DMA2D_FORCE_RESET();
    __HAL_RCC_DMA2D_RELEASE_RESET();

    /* Add transfer complete callback function */
    hdma2d.XferCpltCallback = DMA2D_XferCpltCallback;

    /* Add transfer error callback function */
    hdma2d.XferErrorCallback = DMA2D_XferErrorCallback;

    /* Enable DMA2D global Interrupt */
    NVIC_EnableIRQ(DMA2D_IRQn);
}

inline uint32_t STM32DMA::getChromARTInputFormat(Bitmap::BitmapFormat format)
{
    // Default color mode set to ARGB8888
    uint32_t dma2dColorMode = DMA2D_INPUT_ARGB8888;

    switch (format)
    {
    case Bitmap::ARGB8888: /* DMA2D input mode set to 32bit ARGB */
        dma2dColorMode = DMA2D_INPUT_ARGB8888;
        break;
    case Bitmap::RGB888: /* DMA2D input mode set to 24bit RGB */
        dma2dColorMode = DMA2D_INPUT_RGB888;
        break;
    case Bitmap::RGB565: /* DMA2D input mode set to 16bit RGB */
        dma2dColorMode = DMA2D_INPUT_RGB565;
        break;
    case Bitmap::ARGB2222: /* Fall through */
    case Bitmap::ABGR2222: /* Fall through */
    case Bitmap::RGBA2222: /* Fall through */
    case Bitmap::BGRA2222: /* Fall through */
    case Bitmap::L8:       /* DMA2D input mode set to 8bit Color Look up table*/
        dma2dColorMode = DMA2D_INPUT_L8;
        break;
    case Bitmap::BW:     /* Fall through */
    case Bitmap::BW_RLE: /* Fall through */
    case Bitmap::GRAY4:  /* Fall through */
    case Bitmap::GRAY2:  /* Fall through */
    default:             /* Unsupported input format for DMA2D */
        assert(0 && "Unsupported Format!");
        break;
    }

    return dma2dColorMode;
}

inline uint32_t STM32DMA::getChromARTOutputFormat(Bitmap::BitmapFormat format)
{
    // Default color mode set to ARGB8888
    uint32_t dma2dColorMode = DMA2D_OUTPUT_ARGB8888;

    switch (format)
    {
    case Bitmap::ARGB8888: /* DMA2D output mode set to 32bit ARGB */
        dma2dColorMode = DMA2D_OUTPUT_ARGB8888;
        break;
    case Bitmap::RGB888:   /* Fall through */
    case Bitmap::ARGB2222: /* Fall through */
    case Bitmap::ABGR2222: /* Fall through */
    case Bitmap::RGBA2222: /* Fall through */
    case Bitmap::BGRA2222: /* DMA2D output mode set to 24bit RGB */
        dma2dColorMode = DMA2D_OUTPUT_RGB888;
        break;
    case Bitmap::RGB565: /* DMA2D output mode set to 16bit RGB */
        dma2dColorMode = DMA2D_OUTPUT_RGB565;
        break;
    case Bitmap::L8:     /* Fall through */
    case Bitmap::BW:     /* Fall through */
    case Bitmap::BW_RLE: /* Fall through */
    case Bitmap::GRAY4:  /* Fall through */
    case Bitmap::GRAY2:  /* Fall through */
    default:             /* Unsupported output format for DMA2D */
        assert(0 && "Unsupported Format!");
        break;
    }

    return dma2dColorMode;
}

BlitOperations STM32DMA::getBlitCaps()
{
    /* Report that we only support the word operations */
    return static_cast<BlitOperations>(BLIT_OP_FILL_16BIT |
                                       BLIT_OP_COPY_16BIT);
}

/*
 * void STM32DMA::setupDataCopy(const BlitOp& blitOp) handles blit operation of
 * BLIT_OP_COPY_16BIT
 */
void STM32DMA::setupDataCopy(const BlitOp& blitOp)
{
    uint32_t dma2dForegroundColorMode = getChromARTInputFormat(static_cast<Bitmap::BitmapFormat>(blitOp.srcFormat));
    uint32_t dma2dOutputColorMode = getChromARTOutputFormat(static_cast<Bitmap::BitmapFormat>(blitOp.dstFormat));

    /* DMA2D OOR register configuration */
    WRITE_REG(DMA2D->OOR, blitOp.dstLoopStride - blitOp.nSteps);

    /* DMA2D BGOR register configuration */
    WRITE_REG(DMA2D->BGOR, blitOp.dstLoopStride - blitOp.nSteps);

    /* DMA2D FGOR register configuration */
    WRITE_REG(DMA2D->FGOR, blitOp.srcLoopStride - blitOp.nSteps);

    /* DMA2D OPFCCR register configuration */
    WRITE_REG(DMA2D->OPFCCR, dma2dOutputColorMode);

    /* Configure DMA2D data size */
    WRITE_REG(DMA2D->NLR, (blitOp.nLoops | (blitOp.nSteps << DMA2D_NLR_PL_Pos)));

    /* Configure DMA2D destination address */
    WRITE_REG(DMA2D->OMAR, reinterpret_cast<uint32_t>(blitOp.pDst));

    /* Configure DMA2D source address */
    WRITE_REG(DMA2D->FGMAR, reinterpret_cast<uint32_t>(blitOp.pSrc));

    /* Set DMA2D color mode and alpha mode */
    WRITE_REG(DMA2D->FGPFCCR, dma2dForegroundColorMode | (DMA2D_COMBINE_ALPHA << DMA2D_FGPFCCR_AM_Pos) | (blitOp.alpha << 24));

    /* Start DMA2D */
    WRITE_REG(DMA2D->CR, DMA2D_M2M | DMA2D_IT_TC | DMA2D_CR_START | DMA2D_IT_CE | DMA2D_IT_TE);
}

/*
 * void STM32DMA::setupDataFill(const BlitOp& blitOp) handles blit operation of
 * BLIT_OP_FILL_16BIT
 */
void STM32DMA::setupDataFill(const BlitOp& blitOp)
{
    uint32_t dma2dOutputColorMode = getChromARTOutputFormat(static_cast<Bitmap::BitmapFormat>(blitOp.dstFormat));

    /* DMA2D OPFCCR register configuration */
    WRITE_REG(DMA2D->OPFCCR, dma2dOutputColorMode);

    /* Configure DMA2D data size */
    WRITE_REG(DMA2D->NLR, (blitOp.nLoops | (blitOp.nSteps << DMA2D_NLR_PL_Pos)));

    /* Configure DMA2D destination address */
    WRITE_REG(DMA2D->OMAR, reinterpret_cast<uint32_t>(blitOp.pDst));

    /* DMA2D OOR register configuration */
    WRITE_REG(DMA2D->OOR, blitOp.dstLoopStride - blitOp.nSteps);

    /* Write DMA2D FGPFCCR register */
    WRITE_REG(DMA2D->FGPFCCR, dma2dOutputColorMode | (DMA2D_NO_MODIF_ALPHA << DMA2D_FGPFCCR_AM_Pos));

    /* DMA2D FGOR register configuration */
    WRITE_REG(DMA2D->FGOR, 0);

    /* Set color */
    WRITE_REG(DMA2D->OCOLR, blitOp.color);

    /* Enable the Peripheral and Enable the transfer complete interrupt */
    DMA2D->CR = (DMA2D_IT_TC | DMA2D_CR_START | DMA2D_R2M | DMA2D_IT_CE | DMA2D_IT_TE);
}

namespace touchgfx
{
namespace paint
{
namespace
{
const clutData_t* L8CLUT = 0;
uint32_t L8ClutLoaded = 0;
} // namespace

void setL8Palette(const uint8_t* const data)
{
    L8CLUT = reinterpret_cast<const clutData_t*>(data - offsetof(clutData_t, data));
    L8ClutLoaded = 0;
}

/**
 * @fn void tearDown();
 *
 * @brief Waits until previous DMA drawing operation has finished
 */
void tearDown()
{
    /* Wait for DMA2D to finish last run */
    while ((READ_REG(DMA2D->CR) & DMA2D_CR_START) != 0U);

    /* Clear transfer flags */
    WRITE_REG(DMA2D->IFCR, DMA2D_FLAG_TC | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
}

/** Flushes a line of pixels in the data cache if used.
 *
 * @brief Flushes decoded RGB pixels when rendering compressed images
 */
void flushLine(uint32_t* addr, int sizebytes)
{
    // This function is used when decompressing data to flush
    // the currently decoded data in the cache to allow the DMA2D
    // to blend the pixels correctly.
    if (SCB->CCR & SCB_CCR_DC_Msk)
    {
        SCB_CleanDCache_by_Addr(addr, sizebytes);
    }
}

/**
 * @fn void invalidateTextureCache();
 *
 * @brief Flushes the data cache if used.
 */
void invalidateTextureCache()
{
}
} // namespace paint
} // namespace touchgfx
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
